<!DOCTYPE html>
<html>
    <head>
        <title>Hello, Final</title>
        <style>
            body {
                display: flex;
                justify-content: center;
                flex-direction: column;
            }
            canvas {
                width: auto;
                height: auto;
            }
            #the-canvas { 
                border: 4px solid rgb(0, 139, 44); 
                display: block; 
                margin: 0 auto;
                
            }
        </style>
        <div>
            Behold
        </div>
    </head>

    <body style = "background-color: rgb(39, 39, 39);">
        <canvas id = "the-canvas" width = "960" height = "540"></canvas>
        
        <script src = "vector_template.js"></script>
        <script src = "matrix_template.js"></script>
        <script src = "keys.js"></script>
        <script src = "lib.js"></script>
<!--        <script src = "mesh.js"></script>-->
        <script src = "uv_mesh.js"></script>
        <script src = "texture.js"></script>
        <script src = "material.js"></script>
        
        <script>

            let canvas = document.getElementById( 'the-canvas' );
            
            /** @type {WebGLRenderingContext} */
            let gl = canvas.getContext( 'webgl2' );   

            
            let keyListener = Keys.start_listening();
            let camera = new Mat4();
            let translateX = 0;
            let translateY = 0;
            let translateZ = 0;

            let rotXZAmt = 0; // pitch
            let rotYZAmt = 0; // yaw
            let rotXYAmt = 0; // roll

            let TRANS_AMT = 0.03;
            let ROT_AMT = 0.003;
            let DESIRED_MSPT = 1000/60;
            let tempMatrix = new Mat4();
            let modelView = new Mat4();


            function update() {
                let oldCam = camera.clone().inverse();
                let val0 = oldCam.rc(0, 2);
                let val1 = oldCam.rc(1, 2);
                let val2 = oldCam.rc(2, 2);
                // Tells me which way camera is pointing 
                let forwardVec = new Vec4(val0, val1, val2, 0);

                let val3 = oldCam.rc(0, 0);
                let val4 = oldCam.rc(1, 0);
                let val5 = oldCam.rc(2, 0);
                // Tells me which way camera is pointing 
                let sideVec = new Vec4(val3, val4, val5, 0);

                
                let val6 = oldCam.rc(0, 1);
                let val7 = oldCam.rc(1, 1);
                let val8 = oldCam.rc(2, 1);
                // Tells me which way camera is pointing 
                let heightVec = new Vec4(val6, val7, val8, 0);

            // rotating scene objects, moving the camera
                if(keyListener.is_key_down("KeyW")) {
                    // translateZ += TRANS_AMT;
                    // console.log(forwardVec);
                    camera = tempMatrix.mul(Mat4.translation(translateX += (forwardVec.x*TRANS_AMT), translateY += (forwardVec.y*TRANS_AMT), translateZ += (forwardVec.z*TRANS_AMT)))
                    .mul(Mat4.rotation_xz(rotXZAmt)).mul(Mat4.rotation_yz(rotYZAmt)).mul(Mat4.rotation_xy(rotXYAmt)).inverse();
                }
                if(keyListener.is_key_down("KeyS")) {
                    // translateZ -= TRANS_AMT;
                    camera = tempMatrix.mul(Mat4.translation(translateX -= (forwardVec.x*TRANS_AMT), translateY -= (forwardVec.y*TRANS_AMT), translateZ -= (forwardVec.z*TRANS_AMT)))
                    .mul(Mat4.rotation_xz(rotXZAmt)).mul(Mat4.rotation_yz(rotYZAmt)).mul(Mat4.rotation_xy(rotXYAmt)).inverse();
                }
                if(keyListener.is_key_down("KeyA")) {
                    // translateX -= TRANS_AMT;
                    camera = tempMatrix.mul(Mat4.translation(translateX -= (sideVec.x*TRANS_AMT), translateY -= (sideVec.y*TRANS_AMT), translateZ -= (sideVec.z*TRANS_AMT)))
                    .mul(Mat4.rotation_xz(rotXZAmt)).mul(Mat4.rotation_yz(rotYZAmt)).mul(Mat4.rotation_xy(rotXYAmt)).inverse();
                }
                if(keyListener.is_key_down("KeyD")) {
                    // translateX += TRANS_AMT;
                    camera = tempMatrix.mul(Mat4.translation(translateX += (sideVec.x*TRANS_AMT), translateY += (sideVec.y*TRANS_AMT), translateZ += (sideVec.z*TRANS_AMT)))
                    .mul(Mat4.rotation_xz(rotXZAmt)).mul(Mat4.rotation_yz(rotYZAmt)).mul(Mat4.rotation_xy(rotXYAmt)).inverse();
                }
                if(keyListener.is_key_down("KeyC")) {
                    // translateY -= TRANS_AMT;
                    camera = tempMatrix.mul(Mat4.translation(translateX -= (heightVec.x*TRANS_AMT), translateY -= (heightVec.y*TRANS_AMT), translateZ -= (heightVec.z*TRANS_AMT)))
                    .mul(Mat4.rotation_xz(rotXZAmt)).mul(Mat4.rotation_yz(rotYZAmt)).mul(Mat4.rotation_xy(rotXYAmt)).inverse();
                }
                if(keyListener.is_key_down("Space")) {
                    // translateY += TRANS_AMT;
                    camera = tempMatrix.mul(Mat4.translation(translateX += (heightVec.x*TRANS_AMT), translateY += (heightVec.y*TRANS_AMT), translateZ += (heightVec.z*TRANS_AMT)))
                    .mul(Mat4.rotation_xz(rotXZAmt)).mul(Mat4.rotation_yz(rotYZAmt)).mul(Mat4.rotation_xy(rotXYAmt)).inverse();
                }

                if(keyListener.is_key_down("KeyQ")) {
                    rotXYAmt -= ROT_AMT;
                    camera = tempMatrix.mul(Mat4.translation(translateX, translateY, translateZ)).mul(Mat4.rotation_xz(rotXZAmt)).mul(Mat4.rotation_yz(rotYZAmt)).mul(Mat4.rotation_xy(rotXYAmt)).inverse();
                }
                if(keyListener.is_key_down("KeyE")) {
                    rotXYAmt += ROT_AMT;
                    camera = tempMatrix.mul(Mat4.translation(translateX, translateY, translateZ)).mul(Mat4.rotation_xz(rotXZAmt)).mul(Mat4.rotation_yz(rotYZAmt)).mul(Mat4.rotation_xy(rotXYAmt)).inverse();
                }
                if(keyListener.is_key_down("ArrowLeft")) {
                    rotXZAmt -= ROT_AMT;
                    camera = tempMatrix.mul(Mat4.translation(translateX, translateY, translateZ)).mul(Mat4.rotation_xz(rotXZAmt)).mul(Mat4.rotation_yz(rotYZAmt)).mul(Mat4.rotation_xy(rotXYAmt)).inverse();
                }
                if(keyListener.is_key_down("ArrowRight")) {
                    rotXZAmt += ROT_AMT;
                    camera = tempMatrix.mul(Mat4.translation(translateX, translateY, translateZ)).mul(Mat4.rotation_xz(rotXZAmt)).mul(Mat4.rotation_yz(rotYZAmt)).mul(Mat4.rotation_xy(rotXYAmt)).inverse();
                }
                if(keyListener.is_key_down("ArrowUp")) {
                    rotYZAmt -= ROT_AMT;
                    camera = tempMatrix.mul(Mat4.translation(translateX, translateY, translateZ)).mul(Mat4.rotation_xz(rotXZAmt)).mul(Mat4.rotation_yz(rotYZAmt)).mul(Mat4.rotation_xy(rotXYAmt)).inverse();
                } 
                if(keyListener.is_key_down("ArrowDown")) {
                    rotYZAmt += ROT_AMT;
                    camera = tempMatrix.mul(Mat4.translation(translateX, translateY, translateZ)).mul(Mat4.rotation_xz(rotXZAmt)).mul(Mat4.rotation_yz(rotYZAmt)).mul(Mat4.rotation_xy(rotXYAmt)).inverse();
                }


            }






            // image is not yet loaded
            let loaded = false;

            // let image = new Image();
            // image.onload = on_load;
            // image.src = "tex/texture_map.png";
            // image.src = "tex/metal_scale.png";


            // let tex = gl.createTexture();



            /**
             * Function to bind and load the texture
             */
            function on_load() {

                gl.bindTexture( gl.TEXTURE_2D, tex );

                let loc = gl.getUniformLocation( shader_program, 'tex_0');
                gl.uniform1i( loc, 0 ); 
                
                gl.texImage2D(
                    gl.TEXTURE_2D, 0, gl.RGBA,
                    gl.RGBA, gl.UNSIGNED_BYTE, image );

                // set_uniform_scalar(gl, shader_program, 'mat_ambient', 0.25);
                // set_uniform_scalar(gl, shader_program, 'mat_diffuse', 1.0);
                // set_uniform_scalar(gl, shader_program, 'mat_specular', 2.0);
                // set_uniform_scalar(gl, shader_program, 'mat_shininess', 4.0);
                //
                // set_uniform_vec3(gl, shader_program, 'sun_dir', [150, 0, 2]);
                // set_uniform_vec3(gl, shader_program, 'sun_color', [0.75, 0.75, 0.75]);
                //
                // set_uniform_vec3(gl, shader_program, 'point_color', [30, 0, 0]);
                // set_uniform_vec3(gl, shader_program, 'point_location', [-3, -3, 4]);
                set_all_uniforms(gl, shader_program);
                
                // image has loaded, can allow it to render now
                loaded = true;

            }



            // gl.texImage2D(
            //     gl.TEXTURE_2D,
            //     0, gl.RGBA,
            //     256, 256, 0,
            //     gl.RGBA, gl.UNSIGNED_BYTE,
            //     xor_texture()
            // );


        function render(now) {
            time_delta = ( now - last_update ) / 1000;
            if(mesh !== null) {

                gl.clear( gl.COLOR_BUFFER_BIT );

                let scaleMatrix = Mat4.scale(0.5, 0.5, 0.5);
                let transMatrix = Mat4.translation(0, 0, 4);

                let model = transMatrix.mul(scaleMatrix);

                // Create the perspective matrix (make last value lower to allow objects to get closer)
                let perspective = Mat4.perspectiveX(0.25, 16/9, 0.125, 128);
                // let viewY = Mat4.perspectiveY(1/6, 16/9, -1, 1);
                let realModelView = camera.mul(model);
                // create the model view
                modelView = perspective.mul(camera);
                modelView = modelView.mul(model);

                set_uniform_matrix4(gl, shader_program, "modelview", modelView.data);
                set_uniform_matrix4(gl, shader_program, "model", model.data);
                set_uniform_matrix4(gl, shader_program, "realModelView", realModelView.data);
                // set_render_params(gl);

                // if image is not loaded, dont render the mesh yet 
                if(loaded) {
                }
                mesh.render(gl);


            }
            requestAnimationFrame( render ); 
            last_update = now;
        }


            // SHADERS =======================
            let vertex_source = 
            `   #version 300 es
                precision mediump float;

                uniform mat4 modelview; // model, view, & persective 
                uniform mat4 model; // scaling, rotations, translations
                uniform mat4 realModelView; // model & camera (the true 'modelview')

                uniform float mat_ambient;
                uniform float mat_diffuse;
                uniform float mat_specular;
                uniform float mat_shininess;

                uniform vec3 sun_dir;
                uniform vec3 sun_color;
                uniform vec3 sun_ambient;
                uniform vec3 sun_diffuse;

                uniform vec3 point_color;
                uniform vec3 point_location;

                in vec3 coordinates;
                in vec4 color;
                in vec2 uv;
                in vec3 normal;

                out vec4 v_color;
                out vec2 v_uv;
                out vec3 v_normal;


                vec3 diff_color( vec3 normal, vec3 light_dir,vec3 light_color, float mat_diffuse ) { 
                    return mat_diffuse * light_color * max( dot( normal, light_dir ), 0.0 );
                }

                vec4 createLight(vec3 normal, vec3 toward_light, vec3 to_cam, vec3 light_color) {
                    float dotNormAndLight = dot(normal, toward_light);

                    if(dotNormAndLight < 0.0) {
                        return vec4(0.0, 0.0, 0.0, 0.0);
                    }

                    vec3 reflection = normalize((2.0 * dotNormAndLight * normal) - toward_light);
                    
                    float angle = dot(reflection, to_cam);
                    angle = max(angle, 0.0);
                    angle = pow(angle, mat_shininess);
                    vec4 spec = vec4(angle * mat_specular * light_color, 0);

                    return spec;
                }

                
                void main( void ) {
                    // AMBIENT
                    vec4 ambient_color = vec4( mat_ambient, mat_ambient, mat_ambient, 1.0 );

                    // DIFFUSE FOR SUN
                    vec3 diffuse_color = diff_color(normalize(mat3(model) * normal), normalize(sun_dir), (sun_color), mat_diffuse );
                    vec4 diff4 = vec4(diffuse_color.x, diffuse_color.y, diffuse_color.z, 0);

                    vec3 cam_coords = (realModelView * vec4(coordinates, 1.0)).xyz;

                    // SPECULAR FOR SUN
                    vec3 toward_sun = normalize(sun_dir);
                    vec3 normCoords = normalize(coordinates);
                    vec3 normNormal = normalize(mat3(model) * normal); 
                    vec3 to_cam = normalize(-1.0 * cam_coords);
                    vec4 spec = createLight(normNormal, toward_sun, to_cam, sun_color);

                    // POINT LIGHT DIFFUSE AND SPECULAR
                    vec3 point_coords = (model * vec4(coordinates, 1.0)).xyz;
                    vec3 point_dir = normalize(point_location - point_coords);
                    vec3 point_diffuse = diff_color(normalize(mat3(model) * normal), point_dir, point_color, mat_diffuse);
                    vec4 point_diff4 = vec4(point_diffuse.x, point_diffuse.y, point_diffuse.z, 1.0);

                    vec4 point_spec = createLight(normNormal, point_dir, to_cam, point_color);
                    

                    // ATTENUATION
                    float d = length(point_location);
                    float attenuation = 1.0 / (d*d);
                    vec4 color_from_light = (point_diff4 + point_spec) * attenuation;


                    gl_Position =  modelview * vec4( coordinates, 1.0 );
                    color;
                    v_color = ambient_color + spec + diff4 + color_from_light;
                    v_uv = uv;
                    v_normal = normal;
                }
            `;

            let fragment_source = 
            `   #version 300 es
                precision mediump float;

                in vec4 v_color;
                in vec2 v_uv;
                // in vec3 v_normal;

                out vec4 f_color;
                uniform sampler2D tex_0; 

                void main( void ) {
                    //f_color = v_color; 
                    f_color = texture( tex_0, v_uv ) * v_color;
                }
            `;

            
            let vert_shader = gl.createShader( gl.VERTEX_SHADER );
            let frag_shader = gl.createShader( gl.FRAGMENT_SHADER );            
            
            // load strings into the shader
            gl.shaderSource( vert_shader, vertex_source );
            gl.shaderSource( frag_shader, fragment_source );
            
            // compile, attach shaders, and link our shaders, bind outputs and inputss
            gl.compileShader( vert_shader );
            gl.compileShader( frag_shader );

            // SHADER PROGRAM =======================
            let shader_program = gl.createProgram();
            gl.attachShader( shader_program, vert_shader );
            gl.attachShader( shader_program, frag_shader );
            gl.linkProgram( shader_program );

            gl.useProgram( shader_program );

            gl.clearColor( 0.6, 0.9, 1.0, 1 );
            
            // let loaded_mesh = Mesh.quadBox(gl, shader_program, 4, 4, 4);
            // let loaded_mesh = Mesh.uvSphere(gl, shader_program, 16);
            let mapped = new Material( gl, 'tex/texture_map.png', gl.LINEAR_MIPMAP_LINEAR );
            set_all_uniforms(gl, shader_program);
            // setAllUniforms(gl, shader_program);
            let loaded_mesh = UvMesh.uvSphere( gl, shader_program, 16, mapped );


            saveMesh(loaded_mesh);

            setInterval(update, DESIRED_MSPT);

            requestAnimationFrame( render ); 
        </script>
    </body>
</html>